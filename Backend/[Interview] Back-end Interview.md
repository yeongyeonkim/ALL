#### Java에서 Static 사용을 지양해야하는 이유?

> 캡슐화, 재사용성 등의 측면에서 OOP 특징과 맞지 않아서.

* 객체 지향적이지 않다.
  * static은 전역 변수를 사용할 때 유용하다. 하지만 객체 지향 프로그래밍(OOP) 원칙에 따르면, 한 객체가 지닌 데이터는 외부에서 접근하여 수정할 수 없도록 해야함. **캡슐화** 원칙에 위반된다.
* 재사용성이 떨어진다.
  * static 메서드는 `interface` 구현하는데 사용될 수 없다. -> 객체지향적 설계에 방해될 수 있다.

---

#### 시간복잡도란?

* 문제를 해결하는데 걸리는 시간과 입력의 함수 관계

* 빅-오 표기법을 사용하여 나타내며, 계수와 낮은 차수의 항을 제외시키는 방법이다.

  e.g. 크기 n의 모든 입력에 대한 알고리즘에 필요한 시간이 최대 `5n^3 + 3n`의 식을 가진다면, 이 알고리즘의 점진적 시간 복잡도는 `O(n^3)` 이라고 할 수 있다.

---

#### 멀티 프로세스로 할 수 있는 작업을 하나의 프로세스에서 스레드로 나눠가며 하는 이유

* OS가 시스템 자원을 효율적으로 관리하기 위해 스레드를 사용한다.
* 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 **시스템 콜**이 줄어들어 자원을 효율적으로 관리할 수 잇다.
* 프로세스 간의 통신보다 스레드 간의 통신 비용이 적으므로 부담이 줄어든다.

---

#### Java가 실행되는 과정

1. `.java` 소스코드를 javac라는 컴파일러가 컴퓨터가 이해할 수 있도록 기계어로 변경하기 위해 `.class` 바이트 코드로 변환한다. 
2. JVM을 구동시켜 `.class` 바이트 코드를 해석하여 자바 프로그램이 실행된다.

-> 바이트 코드는 JVM이 이해할 수 있는 언어로 변환된 코드로, JVM만 설치되어 있다면 어떤 운영체제에서라도 실행될 수 있다.

![jvm](img/jvm.PNG)

* 일반 프로그램은 OS가 프로그램을 실행시킨다. 반면 자바 프로그램은 운영체제가 JVM을 실행시키면 JVM이 `.class` 파일을 해석하여 자바 프로그램을 실행시킨다.

##### JVM

* `.class` 파일을 읽어 자바 프로그램을 실행함
* GC(Garbage Collection)을 수행한다.

---

#### Index

RDBMS에서 대용량의 데이터(레코드)가 있을 때, 특정 데이터를 검색하기 위해 Full Scan하는 것이 아니라, 인덱스가 적용된 컬럼의 테이블(컬럼, 인덱스 주소)을 따로 파일로 저장해놓고 그것을 검색하여 검색 효율을 높이는 방법

---

#### 생성자 주입 사용 이유?

1. NPE 방지 + 테스트 코드 작성 용이- 의존 관계 설정이 되지 않으면 객체 생성 불가, 컴파일 타임에 인지 가능하기에
   * 필드 인젝션은 스프링의 IoC 컨테이너가 다 생성해서 주입해주는 방식으로 외부로 노출되어있는 것이 하나도 없어서 의존관계를 가지고 있는 메소드의 단위테스트를 작성하면 NPE가 발생한다.
2. 객체의 불변성 확보 - 의존성 주입이 필요한 필드를 final로 선언 가능
3. 순환 참조 방지 - 애플리케이션 구동 전 컴파일 에러로 예외 발생으로 알 수 있음.

---

#### 토큰 세션 차이 및 구현 방법

1. 

---

#### Redis Cache 적용 방법



---

#### Junit TC 방식



---

#### 효율개선 - 큐잉처리





---

#### 자바의 모든 클래스는 'Object' 클래스를 상속받는다. 그리고 이 'Object' 클래스는 equals()와 hashCode() 메소드가 선언되어 있다. 이 메소드들의 역할 및 차이점은?



> 꼬리 질문: 'hashCode'를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수 있다. 어떤 케이스일 때 그럴 수 있는지?

---

#### 싱글 스레드 환경에서 synchorinzed 사용하면 성능은 동일한가? 느리다면 어떻게?

* 거의 차이없다. 경쟁하지 않는 lock을 획득하기 위한 약간의 오버헤드가 생길 수 있지만

  최신 JVM에서는 매우 적은 수준이다. Java SE 6 부터 바이어스 잠금을 통해 비경쟁 동기화 성능을 향상시켜 런타임 최적화를 해주고 있기 때문이다.
