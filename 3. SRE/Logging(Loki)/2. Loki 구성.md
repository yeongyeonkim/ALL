## Loki Architecture
![2-1](img/2-1.png)
* <b>Read Path와 Write Path</b>: Loki는 로그 데이터 처리를 위한 읽기 경로(Read Path)와 쓰기 경로(Write Path)를 구분합니다. 이러한 분리는 데이터 처리의 효율성을 극대화하며, 각 경로는 특정 작업에 최적화된 컴포넌트로 구성됩니다.

### Loki Component

<b>Distributor(로그 수집 및 전처리)</b>
* 클라이언트(fluent-bit)에서 들어오는 로그를 받아서 로그의 정확성을 검증하고 Ingestor에 전달한다.

<b>Ingester(로그 저장)</b>
* 로그 스트림을 메모리에 chunks 단위로 저장하고, 일정 후에 장기 저장소(S3)에 저장한다.

<b>Querier(쿼리 처리 및 결과 반환)</b>
* Ingester 및 장기 저장소에서 로그 쿼리 한 데이터를 가져온 후, 중복을 제거하여 데이터를 반환한다.

<b>Query-Front(쿼리 최적화 및 캐싱)</b>
* Grafana에서 요청을 수신하고 일부 유효성 검사 및 캐싱을 수행한다.


## Loki 구성

Loki 배포 방식: Scalable + Single Tenant

Scalable 방식 선택 이유
 * 현재 단계에서는 Loki 컴포넌트들의 세부적인 설정이 필요할 정도로 복잡한 요구사항이 없어 microservice 형태의 배포는 과도하다고 판단했다.
Single Tenant 방식 선택 이유
 * Multi tenant 구성 시 Grafana 데이터소스 연결에서 발생하는 이슈 + 테스트 환경에서의 빠른 구축이 필요했음.
 * 추후, 프로덕션 배포 단계에서는 multi-tenant 방식으로 전환할 예정

* https://grafana.com/docs/loki/latest/setup/install/helm/install-scalable/
  을 참고하여 helm-chart로 배포하기로 한다.

  배포 이후, 서비스를 확인하니 Pending 상태가 많았다.

```
	loki-backend-0                                       0/2     Pending   0          2m37s
	loki-backend-1                                       0/2     Pending   0          2m37s
	loki-backend-2                                       0/2     Pending   0          2m37s
	loki-canary-c96wx                                    1/1     Running   0          2m37s
	loki-canary-kpgfn                                    1/1     Running   0          2m4s
	loki-canary-lq774                                    1/1     Running   0          2m37s
	loki-canary-xk84h                                    1/1     Running   0          2m37s
	loki-chunks-cache-0                                  2/2     Running   0          2m37s
	loki-gateway-8478fdc45f-vfh57                        1/1     Running   0          2m37s
	loki-read-6468fcf549-5x9l8                           0/1     Running   0          2m37s
	loki-read-6468fcf549-749lz                           0/1     Running   0          2m37s
	loki-read-6468fcf549-vmxbc                           0/1     Running   0          2m37s
	loki-results-cache-0                                 2/2     Running   0          2m37s
	loki-write-0                                         0/1     Pending   0          2m37s
	loki-write-1                                         0/1     Pending   0          2m37s
	loki-write-2                                         0/1     Pending   0          2m37s
```

* 에러를 보니 PVC 쪽이 잘 붙지 않은 듯 하다.

```
$ kubectl describe pod
 Warning  FailedScheduling  2m48s                  default-scheduler  0/4 nodes are available: pod has unbound immediate PersistentVolumeClaims. preemption: 0/4 nodes are available: 4 Preemption is not helpful for scheduling.

$ kubectl describe pvc
 Normal  FailedBinding  9s (x19 over 4m16s)  persistentvolume-controller  no persistent volumes available for this claim and no storage class is set
```

* 공식 문서에서 제공하는 values.yaml에는 persistence가 없는데 
  기본적으로 read, write, backend Pod들이 필요로하는 듯 하다.

```
	backend:
	  replicas: 3
	  persistence:
		enabled: true
		storageClass: "gp2"
		size: 10Gi
	read:
	  replicas: 3
	  persistence:
		enabled: true
		storageClass: "gp2"
		size: 10Gi
	write:
	  replicas: 3
	  persistence:
		enabled: true
		storageClass: "gp2"
		size: 10Gi
```

* 위와 같이 생성하니 정상적으로 Pod들에 PV가 바인딩되고 running이 되었다.
  하지만 Datasource가 grafana에 연결이 되지 않는다.

* [Stack Overflow](https://stackoverflow.com/questions/73205562/unable-to-add-grafana-loki-datasource-in-kubernetes)에서 해결하였다.

* 결국 [공식 문서](https://grafana.com/docs/loki/latest/operations/multi-tenancy/#manage-tenant-isolation)에서 말하기를, Loki는 기본적으로 다중 다중 테넌트 시스템으로 Loki API 요청은 반드시 요청에 대한 테넌트를 식별할 수 있는 X-Scope-OrgID라는 HTTP header를 포함해야한다. 만약 단일 테넌트로 실행하려는 경우, auth_enabled: false로 해야하고, X-Scope-OrgID header는 필요하지 않으며 fake라는 tenant ID를 갖게된다.

#### Multi-tenancy
* Grafana Loki는 멀티테넌트 모드를 지원하여, 여러 사용자 또는 팀이 동일한 Loki 인스턴스를 공유할 수 있도록 합니다. 이 모드에서는 메모리와 장기 저장소에 있는 모든 데이터가 HTTP 요청의 X-Scope-OrgID 헤더에서 가져온 테넌트 ID에 따라 파티셔닝됩니다.
* 멀티테넌트 모드가 아닐 경우, 테넌트 ID는 "fake"로 설정되며, 이는 모든 사용자의 데이터가 동일한 인덱스와 저장된 청크에 표시됨을 의미합니다. 이 기능은 데이터의 격리와 보안을 강화하며, 리소스 사용의 효율성을 높입니다
![2-4](img/2-4.png)

---

### 참고

* https://grafana.com/docs/loki/latest/setup/install/helm/install-scalable/
* https://dewble.tistory.com/entry/Grafana-Loki-Architecture