# 분산 추적 도구 선정

## 분산 추적이란

분산 추적은 분산 서비스, 애플리케이션 및 데이터베이스를 통과하는 요청을 추적할 수 있도록 하는 기술로
  * 어떤 서비스에 영향을 미쳤는지
  * 각 서비스가 요청을 처리하는 데 걸린 시간은 얼마인지
  * 실패나 병목 현상이 발생한 곳은 어디인지


각 추적은 고유 ID를 가지며 스팬(span)을 통과한다.
* 스팬: 하나의 서비스에서 수행된 작업을 나타내는 Trace 내의 단일 작업
고유 ID, 이름, 메타데이터, 타임스탬프와 같은 정보가 포함되어 있다.

## 분산 추적 도구 비교
분산 추적 도구에는 Jaeger, Tempo, Zipkin이 있다.

Jaeger: 강력하고 상세한 기능을 가지고 있지만, 복잡한 설정 및 배포가 필요하고 운영 비용이 들어간다. 저장소는 Elasticsearch, Cassandra, AWS opensearch
 > 대규모 마이크로 서비스 환경에서 상세한 분석과 강력한 기능이 필요한 경우
Zipkin: 가볍고 쉬운 설치/배포, 기능이 간단하고 확장성이 제한된다. 저장소는 Elasticsearch, Cassandra, AWS opensearch
 > 소규모 프로젝트에서 빠르게 분산 추적을 시작하고 싶을 때
Tempo: 매우 비용 효율적인 저장소(S3), 운영 복장성 최소화, Jaeger만큼의 유연한 쿼리 기능은 없다. 
 > 대량의 추적 데이터를 비용 효율적으로 저장해야하는 경우 + 이미 Grafana/Prometheus를 사용하는 경우
 > Jaeger와 달리 인덱스 구축을 하지 않고 추적 ID 조회에만 의존하여 인프라 복잡성을 줄인다.
 
※ OpenSearch란 무엇일까 (https://aws.amazon.com/ko/what-is/opensearch/)

각각을 실제로 간단히 구현해보고 UI 등을 확인하며 어떤 것이 가시성이 좋고 우리 환경에 맞는지 확인한다.

## 구현

Tempo는 SpringBoot, S3와 연계하여 설치를 했고

나는 Jaeger를 PoC하기로 한다.

### Architecture
https://www.youtube.com/watch?v=ducj4uR_ZoE
전체적인 구조는 이렇다.
Spring Boot -> OpenTelemetry -> Jaeger

SpringBoot에서 4318/v1/metrics로 열어두어 (HTTP일 경우)
otlp (openTelemetry)가 해당 메트릭을 수집해온다.
그리고, jaeger-all-in-one으로 확인한다.

https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/
Traces: /v1/traces
Metrics: /v1/metrics

### Trace 흐름
(가장 잘 정리되고 한 번에 이해되는 글)
https://curiousjinan.tistory.com/entry/jaeger-v2-opentelemetry-tracing-guide 
Spring Boot 애플리케이션에 OpenTelemetry SDK를 적용하면, 각 요청 및 내부 연산에 대한 스팬(Span)이 생성되어 Trace를 구성한다.

1. 애플리케이션 Trace/Span 생성
Spring Boot는 일반적으로 Spring Cloud Sleuth(Micrometer Tracing)나 OpenTelemetry Java Agent를 통해 주요 구간을 자동 계측한다.
예를 들어, HTTP 요청을 수신하면 새 Trace와 Root Span이 시작되고, 이후 DB 쿼리나 REST API 호출마다 자식 Span이 생성된다.
이 Span들은 Trace Context를 통해 서비스 경계를 넘어 전파되며, 각 서비스의 OTel SDK는 부모 컨텍스트를 이어받아 새로운 Span을 생성한다.
이러한 방식으로 분산 시스템 전체에 걸쳐 TraceID로 연결된 Span들의 트리/그래프가 만들어진다.

2. OpenTelemetry SDK의 Exporter 동작
애플리케이션 내 OTel SDK는 일정 시간 또는 Span 배치(batch) 단위로 누적된 Span 데이터를 외부로 전송한다.
이를 담당하는 모듈이 'Exporter'이며, 설정에 따라 OTLP 또는 Jaeger 프로토콜 등을 사용한다.
권장되는 방식은 OTLP gRPC/HTTP Exporter를 사용하는 것으로, OpenTelemetry 공식 가이드도 애플리케이션 수집기(Collector)로 OTLP를 보내는 구성을 모범 사례로 제시한다.
Spring Boot 환경 설정에서 OTLP Exporter를 활성화하고 OTEL_EXPORTER_OTLP_ENDPOINT=http://jaeger-collector:4318 과 같이 Jaeger Collector의 OTP 수신 EndPoint로 지정하면,
SDK가 백그라운드 스레드로 해당 주소에 Span 들을 전송한다. (gRPC 4317, HTTP 4318 포트)

3. 데이터 송신 경로
OTel SDK가 보낸 Span 데이터는 네트워크를 통해 Jaeger 수집 Endpoint로 전송된다.
1. 에이전트(sidecar/ds)경유
2. 직접 Collector 전송
 Spring Boot에서 OpenTelemetry를 사용할 땐 에이전트를 생략하고 애플리케이션에서 바로 Jaeger Collector로 보내는 구성이 흔하다.
 이때, Exporter가 Jaeger Collector의 gRPC/HTTP 주소를 향해 데이터를 보내며, TCP 연결을 사용한다.
3. OTel Collector 에이전트 모드
4. Jaeger Collector 처리 및 저장
5. Jaeger UI를 통한 Trace 조회

https://www.jaegertracing.io/docs/2.0/deployment/kubernetes/
Jaeger Operator로 설치하거나 Jaeger Helm Chart로 배포할 수 있는 듯 하다.

### jaeger v2 operator를 통한 설치
https://www.jaegertracing.io/docs/1.65/deployment/operator/#installing-the-operator-on-kubernetes

1. cert-manager를 설치한다.
 `$ kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.18.2/cert-manager.yaml`
  - Jaeger Operator는 1.31 버전부터 웹훅을 사용하여 Jaeger 사용자 지정 리소스(CR)의 유효성 검사를 하기 때문에 cert-manager가 필요하다.
-> 설치 안하면 에러가 발생한다 (사진)

2-1. Operator 설치 (jaeger)
 `$ kubectl create namespace observability`
 `$ kubectl create -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.65.0/jaeger-operator.yaml -n observability`
  - jager Custom Resource Definition 생성 등

2-2. Operator 설치 (opentelemetry)
https://github.com/jaegertracing/jaeger-operator?tab=readme-ov-file#jaeger-v2-operator
 `$ kubectl apply -f https://github.com/open-telemetry/opentelemetry-operator/releases/latest/download/opentelemetry-operator.yaml`

3. Jaeger 배포
 배포 전략에는 allinone(default), production, streaming이 있다.
 - STRATEGY: allinone(jaeger-collector + jaeger-query + jaeger UI)
 - STORAGE: memory 
```
apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: simplest
```

### Prometheus
https://www.jaegertracing.io/docs/1.65/deployment/operator/#prometheus

### Grafana

DataSource 연동

ConnectionURL: http://jaeger-spm-query.default.svc.cluster.local:16686/jaeger
 - port는 http-query인 16686 포트를 사용한다.
 - /jaeger 경로를 꼭 붙여야한다.


===

## SpringBoot 설정
1. build.gradle
  	implementation 'io.micrometer:micrometer-tracing-bridge-otel'
    implementation 'io.opentelemetry:opentelemetry-exporter-otlp'
2. application.yaml
management:
  tracing:
    enabled: true
    sampling:
      probability: 1.0
  otlp:
    tracing:
      endpoint: http://{ServiceDNS}.local:4318/v1/traces
      
otel:
  service:
    name: ${spring.application.name}
  exporter:
    otlp:
      endpoint: http://{ServiceDNS}.default.svc.cluster.local:4318
      protocol: http/protobuf
  traces:
    exporter: otlp


위의 otel 설정은 변수로도 주입이 가능하다.
https://opentelemetry.io/docs/languages/sdk-configuration/otlp-exporter/

OTEL_EXPORTER_OTLP_ENDPOINT=http://jaeger-collector:4318
OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf

// SpringBoot 3용
            - name: OTEL_EXPORTER_OTLP_TRACES_ENDPOINT
              value: http://jaeger-inmemory-instance-collector.default.svc.cluster.local:4318/v1/traces
// SpringBoot 2 용
            - name: OTEL_EXPORTER_OTLP_ENDPOINT
              value: http://jaeger-inmemory-instance-collector.default.svc.cluster.local:4317
			  
management:
  tracing:
    enabled: true
    sampling:
      probability: 1.0
  otlp:
    tracing:
      # 환경 변수 OTEL_COLLECTOR_URL_MGMT 를 사용합니다.
      endpoint: ${OTEL_COLLECTOR_URL_MGMT:http://{ServiceDNS}.local:4318/v1/traces}
      
otel:
  service:
    name: ${spring.application.name}
  exporter:
    otlp:
      # 환경 변수 OTEL_COLLECTOR_URL 를 사용합니다.
      endpoint: ${OTEL_COLLECTOR_URL:http://{ServiceDNS}.default.svc.cluster.local:4318}
      protocol: http/protobuf
  traces:
    exporter: otlp


export OTEL_COLLECTOR_URL_MGMT=http://my-management-collector:4318/v1/traces
export OTEL_COLLECTOR_URL=http://my-otel-collector:4318

3. 그 외
 - Spring Cloud Sleuth 프레임워크는 Spring Boot 3에서 더 이상 사용되지 않으며 , 추적 기능은 Micrometer Tracing으로 마이그레이션되었습니다.
 - [SpringBoot tracing](https://docs.spring.io/spring-boot/reference/actuator/tracing.html#actuator.micrometer-tracing)




==========================================================================================
https://nginxstore.com/blog/kubernetes/jaeger-opentelemetry-%ED%99%9C%EC%9A%A9-kubernetes-%ED%8A%B8%EB%9E%98%ED%94%BD-%ED%9D%90%EB%A6%84-%EC%B6%94%EC%A0%81/












---
참고자료
 - https://curiousjinan.tistory.com/entry/jaeger-v2-opentelemetry-tracing-guide
 - https://fwani.tistory.com/35
 - https://twofootdog.tistory.com/67
 - https://github.com/jaegertracing/jaeger-operator
 - https://codersociety.com/blog/articles/jaeger-vs-zipkin-vs-tempo
 - https://sysnet4admin.gitbook.io/cncf/blog-and-news-ko/blog/member/tracing
 - https://last9.io/blog/grafana-tempo-vs-jaeger/
 - https://www.baeldung.com/spring-boot-opentelemetry-setup
 
 https://www.youtube.com/watch?v=vx_lQ74HSq4