### Loki 도입 및 배경

#### Loki?

* Grafana Labs에서 개발한 오픈 소스 로그 집계 시스템으로, 클라우드 환경에서 로그를 수집, 저장, 조회하는 데 사용되며 Prometheus와 유사한 구조를 가진다.
 - 전체 로그를 인덱싱하는 대신 메타 정보만 인덱싱하여 저장 공간을 절약하고
 - PromQL과 비슷한 LogQL이라는 쿼리 언어를 통해 로그를 효율적으로 검색할 수 있다.

#### 배경

* [장애 인지 및 알림 구성](https://github.com/yeongyeonkim/ALL/tree/main/Observability/Prometheus%2C%20Grafana%2C%20Alertmanager/HTTP%20%EC%83%81%ED%83%9C%EC%BD%94%EB%93%9C%EC%99%80%20resultcode%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EC%9E%A5%EC%95%A0%20%EC%9D%B8%EC%A7%80%20%EB%B0%8F%20%EC%95%8C%EB%A6%BC)에서 논의된 resultCode에 대한 것을 처리하기 위해서였다.

* ※ resultCode는 우리 프로젝트 애플리케이션에서 API 요청에 대한 HTTP Status Code가 200이지만, 로직적으로 문제가 있거나 에러가 있는 경우도 있어서 추가로 분기할 수 있는 코드를 위해서 상태 값을 만든 것입니다. (0000, 000 일 때 정상)

#### Loki를 선택한 이유

* 이제 resultCode를 Logging 시스템을 구축하고 문제가 되는 로그가 발견되면 알림 기능을 활용해 사내 메신저로 전송을 해야한다.

* 애플리케이션 로깅 도구 대표적인 3가지는 다음과 같았고, 이 중에서 우리는 Grafana Loki를 선택하게 되었다.
 1. Elasticsearch (ELK)
 2. Grafana Loki
 3. Splunk
 
* Grafana는 ELK 스택과 비교하여 '라벨을 통한 빠른 필터링 -> 로그 내용 검색'이 장점이라고 한다.
  ```
    # 라벨로 빠른 필터링
	{service="nginx", env="prod"} 
	# 그 후 로그 내용 검색
	|= "GET /api/users"
  ```
  하지만, 우리가 원하는건 로그 내용에 'resultCode'를 보고 판단하는 것이기 때문에 사실 이 장점은 많이 퇴색되었다.
  이 경우, ELK를 쓰는 것이 좋지만 <b>비용</b>(S3를 스토리지로 비용 친화적)과 <b>기존 시스템과의 자연스러운 통합</b>(기존에 Prometheus, Grafana를 구성하여 사용 중)의 이유로 Loki를 선택하였다.

---

참고

* https://grafana.com/blog/2018/12/12/loki-prometheus-inspired-open-source-logging-for-cloud-natives/#loki
* https://dewble.tistory.com/entry/Grafana-Loki-Architecture