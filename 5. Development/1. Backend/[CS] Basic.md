#### 절차지향, 객체지향

##### 절차 지향 프로그래밍 (PP)

- 프로시저 호출의 개념을 바탕으로 하고 있는 프로그래밍
- 특징
  - 컴퓨터의 처리 구조와 유사해 실행속도가 빠르다는 장점
  - 유지보수가 어려움 (문제 해결을 위해 일부분이 아닌 전체를 수정해야 한다.), 실행 순서가 정해져잇어 코드의 순서가 바뀌면 결과가 바뀔 수 있다는 단점

##### 객체 지향 프로그래밍 (OOP)

* 여러 개의 독립된 단위의 '객체'들의 상호작용으로 프로그램 로직을 구성하는 프로그래밍
* 특징
  * 캡슐화: 특정한 하나의 목적을 위해 필요한 데이터나 메서드를 하나로 묶는 것
    데이터는 외부에서 직접 접근하면 안되고 함수를 통해서만 접근해야 한다.
  * 은닉화: 내부 구조는 private하게 감춰두고 외부에서 조작 가능한 정보만 public으로 공개한다.
  * 상속: 기존 메서드와 변수를 물려받되, 필요한 기능을 더 추가하거나 자식클래스에 맞게 재정의하는 방법,
  * 다형성: 오버라이딩, 오버로딩
  * 추상화: 공통의 속성이나 기능을 묶어 이름을 붙이는 것 (Class를 정의하는 것)

---

#### 동적 할당

* 프로그램이 실행하는 순간 프로그램이 사용할 메모리 크기를 고려하여 메모리 할당이 이루어지는 정적 메모리 할당과 다르게, 프로그램 **실행 시간동안 입력되는 데이터에 맞게 사용할 메모리 공간을 할당**하는 것을 말한다.
* 동적으로 할당된 메모리 공간은 명시적으로 해제하거나 GC(쓰레기 수집)가 일어나기 전까지 유지된다. **C/C++ 같은 GC이 없는 언어**의 경우, 사용자가 직접 free()와 같은 명령어로 해제해야 한다. 그렇지 않으면, **프로세스 heap 영역**에 할당된 동적 할당은 프로세스가 종료되면서 운영 체제에 메모리 리소스가 반납되면서 해제된다. (지역 변수는 스택을 사용)

---

#### Heap, Stack에 관하여

##### 메모리 구조

프로그램이 실행되기 위해서는 프로그램이 OS로부터 메모리 공간을 할당받아야 한다.

1. 코드 영역

   프로그램 코드가 저장되는 영역

2. 데이터 영역

   전역 변수와 정적 변수(static)가 저장되는 영역 (전역은 다른 파일에서도 가능하고, 정적은 해당 파일에서만 접근 가능)

   프로그램이 종료될 때 까지 메모리에 남아있음

3. 스택 영역

   지역 변수와 매개 변수가 저장되는 영역, 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 
   (컴파일 시점에 크기 결정)

4. 힙 영역

   사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다. 
   (런타임 시점에 크기 결정)

##### 스택

* 처리 시간이 힙에 비해 빠르다
* 명시적으로 할당 해제할 필요가 없는 변수(지역, 매개)
* 메모리 부족 문제가 발생할 가능성이 더 높다. (메모리 크기가 힙이 훨씬 크기에)

##### 힙

* 처리 시간이 스택에 비해 느리다.
* 메모리 조각화, 단편화의 문제가 있다.

---

#### 프로세스와 스레드

##### 프로세스

* 프로세스: 메모리에 올라와 실행되고 있는 프로그램의 인스턴스
* 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, heap)을 할당받는다.
* 기본적으로 프로세스당 최소 1개의 스레드를 가지고 있다.

##### 스레드

* 프로세스가 할당받은 자원을 이용하는 실행의 단위(프로세스 내에서 실제로 작업을 수행하는 주체)
* 스레드는 프로세스 내에서 각각 **Stack**만 할당받고 Code, Data, Heap 영역은 공유한다.

##### 멀티 스레드 vs 멀티 프로세스

* 멀티 스레드: 멀티 프로세스보다 적은 메모리 공간을 차지하고 `Context Switching`이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험을 갖고 있다.
  * 자원을 공유하면서 동기화 문제가 발생할 수 있다. (병목 현상, 데드락 etc..)
* 멀티 프로세스: 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지(Context Switching)하는 단점이 있다.
  * Context Switching: 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(Context)를 보관하고 대기하고 있던 다음 프로세스가 동작한 이후 이전에 보관했던 프로세스의 상태를 복구하는 작업

##### 자바에서의 스레드

* 서블릿 객체를 호출하는 것은 스레드
* 애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 스레드

---

#### Spin lock, Mutex, Semaphore

##### 임계구역(Critical Section)

* 여러 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분
* 공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에 접근하지 못하도록 하는 방법이 필요

##### 스핀 락

* 임계 구역에 진입이 불가능할 때 진입이 가능할 때까지 루프를 돌면서 재시도하는 방식 (busy waiting)

  * Context Switching을 줄이기 위한 방식. (하지만 너무 오래 lock을 유지하는 경우 오히려 CPU에 부담을 줄 수 있다)
  * 무한 루프를 돌기보다 일정 시간 lock을 얻을 수 없다면, 잠시 sleep 하는 방식을 사용하는 것이 낫다.

##### 뮤텍스(Lock)

* 여러 스레드를 실행하는 환경에서 자원에 대한 접근을 제한하기 위한 동기화 기술
* lock을 건 스레드 본인이 아니면 lock을 해제할 수 없다. (임계 영역을 나가면서 해제한다.)

##### 세마포어

* 멀티 프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법

##### 차이점 (Mutex vs Semaphore)

* Mutex는 동기화 대상이 오직 1개 일때 사용, Semaphore는 동기화 대상이 1개 이상일 때 사용
* Mutex는 자원을 소유할 수 있고, Semaphore는 자원 소유할 수 없다.
* Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재한다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스가 종료될 때 자동으로 clean up 된다.

---


